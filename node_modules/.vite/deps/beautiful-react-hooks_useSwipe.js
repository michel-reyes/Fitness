import {
  __toESM,
  require_react
} from "./chunk-OMFGQDFA.js";

// node_modules/beautiful-react-hooks/esm/useSwipe.js
var import_react3 = __toESM(require_react());

// node_modules/beautiful-react-hooks/esm/shared/swipeUtils.js
var getPointerCoordinates = (event) => {
  if (event.touches) {
    const { clientX: clientX2, clientY: clientY2 } = event.touches[0];
    return [clientX2, clientY2];
  }
  const { clientX, clientY } = event;
  return [clientX, clientY];
};
var getHorizontalDirection = (alpha) => alpha < 0 ? "right" : "left";
var getVerticalDirection = (alpha) => alpha < 0 ? "down" : "up";
var getDirection = (currentPoint, startingPoint, alpha) => {
  const alphaX = startingPoint[0] - currentPoint[0];
  const alphaY = startingPoint[1] - currentPoint[1];
  if (Math.abs(alphaX) > Math.abs(alphaY)) {
    return getHorizontalDirection(alpha[0]);
  }
  return getVerticalDirection(alpha[1]);
};

// node_modules/beautiful-react-hooks/esm/useEvent.js
var import_react2 = __toESM(require_react());

// node_modules/beautiful-react-hooks/esm/factory/createHandlerSetter.js
var import_react = __toESM(require_react());
var createHandlerSetter = (callback) => {
  const handlerRef = (0, import_react.useRef)(callback);
  const setHandler = (0, import_react.useRef)((nextCallback) => {
    if (typeof nextCallback !== "function") {
      throw new Error("the argument supplied to the 'setHandler' function should be of type function");
    }
    handlerRef.current = nextCallback;
  });
  return [handlerRef, setHandler.current];
};
var createHandlerSetter_default = createHandlerSetter;

// node_modules/beautiful-react-hooks/esm/shared/safeHasOwnProperty.js
var safeHasOwnProperty = (obj, prop) => obj ? Object.prototype.hasOwnProperty.call(obj, prop) : false;
var safeHasOwnProperty_default = safeHasOwnProperty;

// node_modules/beautiful-react-hooks/esm/useEvent.js
var useEvent = (ref, eventName, options) => {
  const [handler, setHandler] = createHandlerSetter_default();
  if (!!ref && !safeHasOwnProperty_default(ref, "current")) {
    throw new Error("Unable to assign any scroll event to the given ref");
  }
  (0, import_react2.useEffect)(() => {
    var _a;
    const cb = (event) => {
      if (handler.current) {
        handler.current(event);
      }
    };
    if (((_a = ref.current) === null || _a === void 0 ? void 0 : _a.addEventListener) && handler.current) {
      ref.current.addEventListener(eventName, cb, options);
    }
    return () => {
      var _a2;
      if (((_a2 = ref.current) === null || _a2 === void 0 ? void 0 : _a2.addEventListener) && handler.current) {
        ref.current.removeEventListener(eventName, cb, options);
      }
    };
  }, [eventName, ref.current, options]);
  return setHandler;
};
var useEvent_default = useEvent;

// node_modules/beautiful-react-hooks/esm/useMouseEvents.js
var useMouseEvents = (targetRef, passive) => {
  const target = targetRef !== null && targetRef !== void 0 ? targetRef : { current: window.document };
  const onMouseDown = useEvent_default(target, "mousedown", { passive });
  const onMouseEnter = useEvent_default(target, "mouseenter", { passive });
  const onMouseLeave = useEvent_default(target, "mouseleave", { passive });
  const onMouseMove = useEvent_default(target, "mousemove", { passive });
  const onMouseOut = useEvent_default(target, "mouseout", { passive });
  const onMouseOver = useEvent_default(target, "mouseover", { passive });
  const onMouseUp = useEvent_default(target, "mouseup", { passive });
  return Object.freeze({
    onMouseDown,
    onMouseEnter,
    onMouseLeave,
    onMouseMove,
    onMouseOut,
    onMouseOver,
    onMouseUp
  });
};
var useMouseEvents_default = useMouseEvents;

// node_modules/beautiful-react-hooks/esm/useTouchEvents.js
var useTouchEvents = (targetRef, passive) => {
  const target = targetRef !== null && targetRef !== void 0 ? targetRef : { current: window.document };
  const onTouchStart = useEvent_default(target, "touchstart", { passive });
  const onTouchEnd = useEvent_default(target, "touchend", { passive });
  const onTouchCancel = useEvent_default(target, "touchcancel", { passive });
  const onTouchMove = useEvent_default(target, "touchmove", { passive });
  return Object.freeze({
    onTouchStart,
    onTouchEnd,
    onTouchCancel,
    onTouchMove
  });
};
var useTouchEvents_default = useTouchEvents;

// node_modules/beautiful-react-hooks/esm/useSwipe.js
var initialState = { swiping: false, direction: void 0, alphaX: 0, alphaY: 0, count: 0 };
var defaultOptions = {
  direction: "both",
  threshold: 10,
  preventDefault: true,
  passive: void 0
};
var isEqual = (prev, next) => prev.swiping === next.swiping && prev.direction === next.direction && prev.count === next.count && prev.alphaX === next.alphaX && prev.alphaY === next.alphaY;
var useSwipe = (targetRef = void 0, options = defaultOptions) => {
  const [state, setState] = (0, import_react3.useState)(initialState);
  const startingPointRef = (0, import_react3.useRef)([-1, -1]);
  const isDraggingRef = (0, import_react3.useRef)(false);
  const opts = Object.assign(Object.assign({}, defaultOptions), options || {});
  const { onMouseDown, onMouseMove, onMouseLeave, onMouseUp } = useMouseEvents_default(targetRef, opts.passive);
  const { onTouchStart, onTouchMove, onTouchEnd, onTouchCancel } = useTouchEvents_default(targetRef, opts.passive);
  const startSwipe = (event) => {
    const [clientX, clientY] = getPointerCoordinates(event);
    startingPointRef.current = [clientX, clientY];
    if (opts.preventDefault) {
      event.preventDefault();
      event.stopPropagation();
    }
  };
  const continueSwipe = (event) => {
    const [clientX, clientY] = getPointerCoordinates(event);
    if (opts.preventDefault) {
      event.preventDefault();
      event.stopPropagation();
    }
    if (isDraggingRef.current || startingPointRef.current[0] !== -1 && startingPointRef.current[1] !== -1) {
      const alpha = [startingPointRef.current[0] - clientX, startingPointRef.current[1] - clientY];
      if (opts.direction === "both" && (Math.abs(alpha[0]) > opts.threshold || Math.abs(alpha[1]) > opts.threshold)) {
        isDraggingRef.current = true;
        const nextState = {
          alphaX: alpha[0],
          alphaY: alpha[1],
          count: state.count,
          swiping: true,
          direction: getDirection([clientX, clientY], startingPointRef.current, alpha)
        };
        if (!isEqual(nextState, state)) {
          setState(nextState);
        }
      }
      if (opts.direction === "horizontal" && Math.abs(alpha[0]) > opts.threshold) {
        isDraggingRef.current = true;
        const nextState = {
          alphaX: alpha[0],
          alphaY: 0,
          count: state.count,
          swiping: true,
          direction: getHorizontalDirection(alpha[0])
        };
        if (!isEqual(nextState, state)) {
          setState(nextState);
        }
      }
      if (opts.direction === "vertical" && Math.abs(alpha[1]) > opts.threshold) {
        isDraggingRef.current = true;
        const nextState = {
          alphaY: alpha[1],
          alphaX: 0,
          count: state.count,
          swiping: true,
          direction: getVerticalDirection(alpha[1])
        };
        if (!isEqual(nextState, state)) {
          setState(nextState);
        }
      }
    }
  };
  const endSwipe = (event) => {
    if (isDraggingRef.current) {
      if (opts.preventDefault) {
        event.preventDefault();
        event.stopPropagation();
      }
      setState((prevState) => Object.assign(Object.assign({}, prevState), { swiping: false, count: state.count + 1 }));
    }
    startingPointRef.current = [-1, -1];
    isDraggingRef.current = false;
  };
  onMouseDown(startSwipe);
  onTouchStart(startSwipe);
  onMouseMove(continueSwipe);
  onTouchMove(continueSwipe);
  onMouseUp(endSwipe);
  onTouchEnd(endSwipe);
  onMouseLeave(endSwipe);
  onTouchCancel(endSwipe);
  return state;
};
var useSwipe_default = useSwipe;
export {
  useSwipe_default as default
};
//# sourceMappingURL=beautiful-react-hooks_useSwipe.js.map
